# -*- coding: utf-8 -*-
"""Banking Analytics assignment 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yApTQxIkv08uQfCn0htrtAWaa__uaVho
"""

import numpy as np 
import pandas as pd

colnames = ["id", "PurchaseDate", "PriceAtCoupon0", "PaymentPeriod", "YearlyRate", "Spread", "CurrentCouponNumbers", "FaceValue", "Corporate", "CouponRate"]
q1Data = pd.read_excel("DataClean2021_update_data.xlsx", names = colnames)
q1Data

pip install quantlib

#load in the yield curves
yieldCurves= pd.read_excel("DataClean2021.xlsx", sheet_name = "YieldCurves")
yieldCurves

numofcouponsarray = []
#function to find the test price of a bond
def bond_price(coupon_rate, spread, number_of_coupons, yields):
    price = 0
    #print("COUP",number_of_coupons, len(yields))
    n = 0
    for n in range(int(number_of_coupons)):
        price  += coupon_rate / (1 + yields[n] + spread) ** (n+1)
    price += 1 / (1 + yields[n] + spread) ** (n+1)
    price = price * 100
    
    return price


def findNumberOfCoupons2(test_price, couponRate, spread, num_of_coupons, yields):
  bondDifference = []
  for i in range(0,num_of_coupons + 1):
    difference = abs(bond_price(couponRate,spread,i, yields) - test_price)
    bondDifference.append(difference)
  #now select the index with the smallest difference
  min_index = bondDifference.index(min(bondDifference))
  return min_index



#for all bonds in the dataset
for i in range(0, len(q1Data)):
  print(i)
  #get the current yields
  currentYields = yieldCurves.iloc[(yieldCurves["Date"] == q1Data.iloc[i,1]).values]
  currentYields = currentYields.iloc[0,2:122]
  #test price is price at coupon 0
  test_price = q1Data.iloc[i,2]
  couponRate = q1Data.iloc[i,9]
  spread =  q1Data.iloc[i,5]
  #if semiannual payments
  if (q1Data.iloc[i,3] == "SemiAnnually"):
    currentYields = currentYields.iloc[range(1,120,2)] / 2 
    #print("Bond pays semiannually")
    numofcouponsarray.append(findNumberOfCoupons2(test_price, couponRate,spread, 60, currentYields))
  elif (q1Data.iloc[i,3] == "Quarterly"):
    currentYields = currentYields / 4
    #print("Bond pays quarterly")
    numofcouponsarray.append(findNumberOfCoupons2(test_price, couponRate,spread, 120, currentYields))
  else:
    #print("bond pays annually")
    currentYields = currentYields.iloc[range(3, 120, 4)]
    numofcouponsarray.append(findNumberOfCoupons2(test_price, couponRate ,spread, 30, currentYields))


print("THE CODE IS DONE RUNNING!!!!")

print(len(numofcouponsarray))
print(numofcouponsarray)
numofcouponsarray = np.asarray(numofcouponsarray)

q1Data["numberOfCoupons"] = numofcouponsarray
q1Data
q1Data.to_csv("q1Done.csv")

currentYields.iloc[0,2:122]

import pandas as pd
q1Data = pd.read_csv("q1Done.csv")
q1Data["CouponsRemaining"] = q1Data["numberOfCoupons"] - q1Data["CurrentCouponNumbers"]

#q1Data.to_csv("updatedDataGood.csv")

q1Data = q1Data.drop("Unnamed: 0", axis = 1)
q1Data

pip install python-dateutil

#question 1b
import pandas as pd
from datetime import date
from dateutil.relativedelta import relativedelta
from dateutil import parser
import datetime
#q1Data = pd.read_csv("updatedDataFinal.csv")
yieldCurves = pd.read_excel("DataClean2021.xlsx", sheet_name = "YieldCurves")
currentCleanPrice = []
currentDirtyPrice = []
def cleanPriceOfBond(couponRate, spread, yields_today,dirtyPrice, number_of_coupons, startdate, typeofbond):
  #function to clean the bond from its dirty price
  startdate = parser.parse(startdate)
  if (typeofbond == "SemiAnnually"):
    last_coupon_date = startdate + relativedelta(months=+(6*number_of_coupons))
    next_coupon_date = last_coupon_date + relativedelta(months=+6)
    today = datetime.datetime(2021,8, 25)
    delta = today -last_coupon_date
    days = delta.days
    Accur_int = couponRate*(1+(yields_today[0]/2+spread)*(days/180))
    cleanPrice = dirtyPrice - Accur_int
    return cleanPrice
  elif (typeofbond == "Quarterly"):
    last_coupon_date = startdate + relativedelta(months= +(3*number_of_coupons))
    next_coupon_date = last_coupon_date + relativedelta(months=+3)
    today = datetime.datetime(2021,8, 25)
    delta = today -last_coupon_date
    days = delta.days
    Accur_int = couponRate*(1+(yields_today[0]/4+spread)*(days/90))
    cleanPrice = dirtyPrice - Accur_int
    return cleanPrice
  else:
    last_coupon_date = startdate + relativedelta(months = +(12*number_of_coupons))
    next_coupon_date = last_coupon_date + relativedelta(months=+12)
    today = datetime.datetime(2021,8, 25)
    print(type(today))
    delta = today - last_coupon_date
    days= delta.days
    Accur_int = couponRate*(1+(yields_today[0]+spread)*(days/360))
    cleanPrice = dirtyPrice - Accur_int
    return cleanPrice



def bond_price(coupon_rate, spread, number_of_coupons_left,currentcoupons, yields, typeofbond, startdate):
    price = 0
    n = 0
    for n in range(int(number_of_coupons_left)):
        price  += coupon_rate / (1 + yields[n] + spread) ** (n+1)
    price += 1 / (1 + yields[n] + spread) ** (n+1)
    price = price * 100
    return cleanPriceOfBond(coupon_rate, spread, yields, price, currentcoupons, startdate, typeofbond)

def bond_price_dirty(coupon_rate, spread, number_of_coupons_left,currentcoupons, yields, typeofbond, startdate):
    price = 0
    n = 0
    for n in range(int(number_of_coupons_left)):
        price  += coupon_rate / (1 + yields[n] + spread) ** (n+1)
    price += 1 / (1 + yields[n] + spread) ** (n+1)
    price = price * 100
    return price


for i in range(0, len(q1Data)):
  print(i)
  august25yields = yieldCurves.iloc[(yieldCurves["Date"] == "8/25/2021").values]
  august25yields = august25yields.iloc[0,2:122]
  startDate = q1Data.iloc[i,1]
  spread = q1Data.iloc[i,5]
  couponRate = q1Data.iloc[i,9]
  numCouponsLeft = q1Data.iloc[i,11]
  currentcoupons = q1Data.iloc[i,6]
  #if semiannual payments
  if (q1Data.iloc[i,3] == "SemiAnnually"):
    typeofbond = "SemiAnnually"
    august25yields = august25yields.iloc[range(1,120,2)] / 2
    #get the current clean and dirty prices
    currentCleanPrice.append(bond_price(couponRate,spread, numCouponsLeft, currentcoupons, august25yields, typeofbond, startDate))
    currentDirtyPrice.append(bond_price_dirty(couponRate, spread, numCouponsLeft, currentcoupons, august25yields, typeofbond, startDate))

  elif (q1Data.iloc[i,3] == "Quarterly"):
    august25yields = august25yields / 4
    typeofbond = "Quarterly"
    currentCleanPrice.append(bond_price(couponRate, spread , numCouponsLeft,currentcoupons, august25yields, typeofbond, startDate))
    currentDirtyPrice.append(bond_price_dirty(couponRate, spread, numCouponsLeft, currentcoupons, august25yields, typeofbond, startDate))

  else:
    typeofbond = "Annually"
    august25yields = august25yields.iloc[range(3,120, 4)]
    currentCleanPrice.append(bond_price(couponRate, spread, numCouponsLeft, currentcoupons, august25yields, typeofbond, startDate))
    currentDirtyPrice.append(bond_price_dirty(couponRate, spread, numCouponsLeft, currentcoupons, august25yields, typeofbond, startDate))


print("Code is Done!")

import numpy as np
currentPrice = np.array(currentCleanPrice)
q1Data["CurrentCleanPrice"] = currentCleanPrice
currentDirtyPrice = np.array(currentDirtyPrice)
q1Data["CurrentDiryPrice"] = currentDirtyPrice
q1Data.to_csv("updatedDataFinal4.csv")

q1Data

q1Data["Price Aug 25"] = (q1Data["CurrentDiryPrice"] / 100) * q1Data["FaceValue"]
q1Data

def annualizeSpread(bondType, spread):
  if(bondType == "SemiAnnually"):
    spread = spread * 2
    return spread
  elif (bondType == "Quarterly"):
    spread = spread * 4
    return spread
  else:
    return spread


q1Data['AnnualizedSpread'] = q1Data.apply(lambda x: annualizeSpread(x.PaymentPeriod, x.Spread), axis = 1)
q1Data

import pandas as pd
import numpy as np
q1Data = pd.read_csv("UPDATEDGOODCOPY (4).csv")
q1Data

print(max(q1Data.AnnualizedSpread))
max_val = max(q1Data.AnnualizedSpread) 
percentiles = [(elem)/max_val * 100 for elem in q1Data.AnnualizedSpread]
percentiles
print(min(percentiles))
print(max(percentiles))

#question 1c
#given a spread, find what percentile it is
from scipy.stats import percentileofscore

all_percentiles = [percentileofscore(q1Data.AnnualizedSpread, value, kind='strict') for value in q1Data.AnnualizedSpread]
all_percentiles = np.array(all_percentiles)


q1Data["SpreadPercentile2"] = all_percentiles


def percentileToPD(spread_percentile):
  if (spread_percentile < 5):
    return 0.001
  elif (spread_percentile > 5 and spread_percentile < 20):
    return 0.01
  elif (spread_percentile > 20 and spread_percentile < 40):
    return 0.12
  elif (spread_percentile > 40 and spread_percentile < 60):
    return 0.36
  elif (spread_percentile > 60 and spread_percentile < 75):
    return 0.52
  elif (spread_percentile > 75 and spread_percentile < 90):
    return 0.75
  else:
    return 0.85


q1Data['PD'] = q1Data.apply(lambda x: percentileToPD(x.SpreadPercentile2), axis = 1)
print(q1Data)



from scipy.stats import norm
def find_b(PD):
  b = (0.11852-0.05487*np.log(PD))**2
  return b
q1Data["b"] = q1Data.apply(lambda x: find_b(x.PD), axis = 1)
q1Data

def find_M(typeofbond, couponsLeft):
  if (typeofbond == "SemiAnnually"):
    M = (couponsLeft * 0.5)
    return M
  elif (typeofbond == "Quarterly"):
    M = (couponsLeft * .25)
    return M
  else:
    M = couponsLeft
    return M

q1Data["M"] = q1Data.apply(lambda x: find_M(x.PaymentPeriod, x.CouponsRemaining), axis = 1)
print(q1Data)

#CONSIDER ALL BONDS AS SUBORDINATED!
#Question 1c
from scipy.stats import norm

LGD = 0.75 #because bonds are subordinated
def find_capital_requirements(PD,LGD, b, M):
  # First part of the equation, lower correlation
  R =  0.12 * ( (1 - np.exp(-50 * PD)) / (1 - np.exp(-50)) )
  # Second part of the equation, higher correlation 
  R += 0.24 * (1 - ( (1 - np.exp(-50 * PD)) / (1 - np.exp(-50)) ) )
  # Now we can calculate the capital
  K = norm.cdf(np.sqrt( (1 - R) ** (-1) ) * norm.ppf(PD) + 
               np.sqrt( R / (1 - R) ) * norm.ppf(0.999) ) - PD
  K *= LGD*((1+(M-2.5)*b)/(1-1.5*b))
  return K


q1Data["CapitalRequirement"] = q1Data.apply(lambda x: find_capital_requirements(x.PD, LGD, x.b, x.M), axis = 1)

#find the total amount
q1Data['Cap_req_amount'] = q1Data.apply(lambda x: x.FaceValue * (x.CurrentDiryPrice/100) * x.CapitalRequirement,axis = 1)
q1Data



#now find the provisions
LGD = 0.75
def provision_requirements(pd, lgd, facevalue, dirtyprice):
  #pd * lgd * ead 
  prov = pd * lgd * facevalue * (dirtyprice / 100)
  return prov

q1Data["Provisions"] = q1Data.apply(lambda x: provision_requirements(x.PD, LGD, x.FaceValue, x.CurrentDiryPrice), axis = 1)
  

q1Data
print(sum(q1Data["Provisions"]))

q1Data.to_csv("FINAL.csv")
print(sum(q1Data.Cap_req_amount))

import matplotlib.pyplot as plt

print(yieldCurves.iloc[0:5,1])

date = yieldCurves.iloc[0:7582,1 ]
yields = yieldCurves.iloc[0:7582, 2]

plt.plot_date(date, yields)
plt.xlabel('Year')
plt.ylabel('Yield of bond')
plt.show()

import random
import numpy
from matplotlib import pyplot

oldPrice = q1Data.PriceAtCoupon0
newPrice= q1Data.CurrentDiryPrice

bins = 10

pyplot.hist(oldPrice, bins, alpha=0.5, label='Old Price ')
pyplot.hist(newPrice, bins, alpha=0.5, label='Price Aug 25th')
pyplot.legend(loc='upper right')
pyplot.xlabel("Price (%)")
pyplot.ylabel("Count")
pyplot.show()

q1Data["Price Aug 25"].head()